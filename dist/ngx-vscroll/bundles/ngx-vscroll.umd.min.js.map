{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://ngx-vscroll/lib/ngx-vscroll.enum.ts","ng://ngx-vscroll/lib/ngx-vscroll.service.ts","ng://ngx-vscroll/lib/ngx-vscroll.component.ts","ng://ngx-vscroll/lib/ngx-vscroll.module.ts"],"names":["__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","NONE","ADD","UPDATE","REMOVE","NgxVScrollService","prototype","getClosestItemIndex","scrollPosition","itemMeta","current","offsetTop","currentIndex","difference","Math","abs","index","newDifference","getViewportMeta","closestRowIndex","buffer","startIndex","count","onItemChange","oldItems","newItems","updationDifference","this","getItemDifferenceForEqualLength","operation","ChangeOperation","diff","additionDifference","getItemDifference","deletionDifference","handleItemChange","processItemMetaForAdd","addedItems","renderedElements","itemsMeta","heights","slice","forEach","item","getBoundingClientRect","height","newArrivals","reduce","previous","above","below","sort","a","b","addedItemIndex","originalIndex","heightAddition","newItemMeta","splice","newArrival","pop","processItemMetaForUpdate","updatedItems","diffIndex","adjustmentHeight","currentHeight","processItemMetaForRemove","removedItems","findIndex","heightSubtraction","renderedItem","updateIndexes","removedIndex","items","map","itemsA","itemsB","_this","itemsAKeys","trackBy","includes","previousObjectindex","prevItem","Injectable","args","providedIn","NgxVScrollComponent","scrollerService","viewportItems","EventEmitter","scrollEnd","setDefaults","Object","defineProperty","scrollParentElementRef","nativeElement","scrollItemsElementRef","ngOnInit","Error","ngOnChanges","changes","itemsChange","firstChange","initialRender","changeData","previousValue","currentValue","scrollTo","options","top","scrollParentDiv","getItemIndex","virtualIndex","lastStartIndex","clonedViewportItems","maxYOffset","scrollHeight","lastCount","mutationObservers","setViewportItems","setTimeout","processItemMeta","setScrollHeight","attachMutationObservers","Array","from","emit","getHtmlElements","element","elementCollection","scrollItemsDiv","childNodes","filter","nodeType","lastItem","onScroll","clearTimeout","isScrolling","isScrollingEvent","handleScroll","scrollTop","updateOffsetYPosition","viewportMeta","deattachMutationObserver","updatePosition","max","change","handleAddChange","handleUpdateChange","handleRemoveChange","_a","apply","renderedElement","updatedItemsOutsideViewport","updatedItemsOnViewport_1","position","style","transform","itemIndex","observer","MutationObserver","onObserve","observe","subtree","childList","adjustmentOffset","disconnect","Component","selector","template","encapsulation","ViewEncapsulation","None","Output","Input","ViewChild","static","NgxVScrollModule","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export enum ChangeOperation {\n  NONE,\n  ADD,\n  UPDATE,\n  REMOVE,\n}\n","import { Injectable } from '@angular/core';\nimport { ItemMeta, ViewportMeta, ItemChange, ItemDiff } from './ngx-vscroll.interface';\nimport { ChangeOperation } from './ngx-vscroll.enum';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NgxVScrollService<T> {\n\n\n  constructor() { }\n\n  trackBy: string;\n\n  getClosestItemIndex(scrollPosition: number, itemMeta: ItemMeta<T>[]) {\n    let current = itemMeta[0].offsetTop;\n    let currentIndex = 0;\n    let difference = Math.abs(scrollPosition - current);\n\n    for (let index = 0; index < itemMeta.length; index++) {\n      const newDifference = Math.abs(scrollPosition - itemMeta[index].offsetTop);\n      if (newDifference < difference) {\n        difference = newDifference;\n        current = itemMeta[index].offsetTop;\n        currentIndex = index;\n      }\n    }\n    return currentIndex;\n  }\n\n  getViewportMeta(closestRowIndex: number, buffer: number, itemMeta: ItemMeta<T>[]): ViewportMeta {\n    let startIndex = closestRowIndex - buffer;\n    let count = closestRowIndex + buffer;\n\n    // Safe check startIndex and count;\n    if (startIndex < 0) {\n      startIndex = 0;\n    }\n    if (count >= itemMeta.length) {\n      count = itemMeta.length;\n    }\n\n    return {\n      count,\n      startIndex,\n    };\n  }\n\n  /**\n   * Find out the difference of item on Add/Update/Remove\n   * @param oldItems Takes previous item list\n   * @param newItems Takes latest item list\n   * @returns Item changes with operation\n   */\n  onItemChange(oldItems: T[], newItems: T[]): ItemChange<T> {\n    if (newItems.length === oldItems.length) {\n      const updationDifference = this.getItemDifferenceForEqualLength(oldItems, newItems);\n      if (updationDifference.length) {\n        return {\n          operation: ChangeOperation.UPDATE,\n          diff: updationDifference\n        };\n      }\n    }\n\n    if (newItems.length > oldItems.length) {\n      const additionDifference = this.getItemDifference(oldItems, newItems);\n      if (additionDifference.length) {\n        return {\n          operation: ChangeOperation.ADD,\n          diff: additionDifference\n        };\n      }\n    }\n\n    if (newItems.length < oldItems.length) {\n      const deletionDifference = this.getItemDifference(newItems, oldItems);\n      if (deletionDifference.length) {\n        return {\n          operation: ChangeOperation.REMOVE,\n          diff: deletionDifference\n        };\n      }\n    }\n\n    return {\n      operation: ChangeOperation.NONE\n    };\n  }\n\n  handleItemChange() {\n\n  }\n\n  processItemMetaForAdd(addedItems: ItemDiff<T>[], renderedElements: HTMLElement[], itemsMeta: ItemMeta<T>[]) {\n    // Filter out only added elements and get height\n    const heights: { [index: number]: number } = {};\n    renderedElements = renderedElements.slice(renderedElements.length - addedItems.length);\n    addedItems.forEach((item, index) => {\n      heights[item.index] = renderedElements[index].getBoundingClientRect().height;\n    });\n\n    // divide items into above and lower bound of itemsMeta\n    const newArrivals = addedItems.reduce((previous, next) => {\n      if (next.index >= itemsMeta.length) {\n        previous.above.push(next);\n      } else {\n        previous.below.push(next);\n      }\n      return previous;\n    }, { above: [], below: [] });\n    newArrivals.above.sort((a, b) => a - b);\n\n    // Process meta for newly added item and\n    // adjust the heights of other items\n    let addedItemIndex = 0;\n    let originalIndex = newArrivals.below.length && newArrivals.below[addedItemIndex].index;\n    let heightAddition = 0;\n\n\n    // loop if items are added in between\n    if (newArrivals.below.length) {\n      for (let index = 0; index < itemsMeta.length; index++) {\n        const itemMeta = itemsMeta[index];\n        if (index === originalIndex) {\n          const newItemMeta: ItemMeta<T> = {\n            height: heights[originalIndex],\n            offsetTop: itemMeta.offsetTop + heightAddition,\n            value: newArrivals.below[addedItemIndex].value\n          };\n          itemsMeta.splice(index, 0, newItemMeta);\n          heightAddition += heights[originalIndex];\n          addedItemIndex = addedItemIndex + 1;\n          originalIndex = newArrivals.below[addedItemIndex] && newArrivals.below[addedItemIndex].index;\n        } else {\n          itemMeta.offsetTop += heightAddition;\n        }\n      }\n    }\n\n    // just push new items at the end of array\n    while (newArrivals.above.length !== 0) {\n      const newArrival = newArrivals.above.pop();\n      const newItemMeta: ItemMeta<T> = {\n        height: heights[newArrival.index],\n        offsetTop: itemsMeta[itemsMeta.length - 1].offsetTop + heights[newArrival.index],\n        value: newArrival.value\n      };\n      itemsMeta.push(newItemMeta);\n    }\n  }\n\n\n  processItemMetaForUpdate(updatedItems: ItemDiff<T>[], renderedElements: HTMLElement[], itemsMeta: ItemMeta<T>[]) {\n    const heights: { [index: number]: number } = {};\n    renderedElements = renderedElements.slice(renderedElements.length - updatedItems.length);\n    updatedItems.forEach((diff, index) => {\n      heights[diff.index] = renderedElements[index].getBoundingClientRect().height;\n    });\n\n    let diffIndex = 0;\n    let originalIndex = updatedItems[diffIndex].index;\n    let adjustmentHeight = 0;\n    for (let index = 0; index < itemsMeta.length; index++) {\n      const itemMeta = itemsMeta[index];\n      if (index === originalIndex) {\n        itemMeta.offsetTop += adjustmentHeight;\n        itemMeta.value = updatedItems[diffIndex].value;\n        const currentHeight = heights[originalIndex];\n        adjustmentHeight += (currentHeight - itemMeta.height);\n        itemMeta.height = currentHeight;\n        diffIndex++;\n        originalIndex = updatedItems[diffIndex] && updatedItems[diffIndex].index;\n      } else {\n        itemMeta.offsetTop += adjustmentHeight;\n      }\n    }\n  }\n\n  processItemMetaForRemove(removedItems: ItemDiff<T>[], itemsMeta: ItemMeta<T>[]) {\n    let diffIndex = 0;\n    let findIndex = removedItems[diffIndex] && removedItems[diffIndex].index;\n    let heightSubtraction = 0;\n    // Following loop is not a simple for loop, as the array being iterated is being mutated in the loop\n    // tslint:disable-next-line: prefer-for-of\n    for (\n      let index = 0, renderedItem = itemsMeta[index];\n      index < itemsMeta.length;\n      index++ , renderedItem = itemsMeta[index]\n    ) {\n      if (index === findIndex) {\n        heightSubtraction += renderedItem.height;\n        itemsMeta.splice(index, 1);\n        removedItems = this.updateIndexes(index, removedItems);\n        index--;\n        diffIndex++;\n        findIndex = removedItems[diffIndex] && removedItems[diffIndex].index;\n      } else {\n        renderedItem.offsetTop -= heightSubtraction;\n      }\n    }\n  }\n\n\n  updateIndexes(removedIndex: number, items: ItemDiff<T>[]) {\n    return items.map(item => {\n      if (item.index > removedIndex) {\n        item.index -= 1;\n      }\n      return item;\n    });\n  }\n\n  /**\n   * Takes 2 param array1 and array2 of type T\n   * @param itemsA Takes old item for add difference and new item for added difference\n   * @param itemsB Takes new item for add difference and old item for deletion difference\n   * @returns ItemDiff of type T\n   */\n  private getItemDifference(itemsA: T[], itemsB: T[]): ItemDiff<T>[] {\n    const itemsAKeys = itemsA.map(item => item[this.trackBy]);\n    const diff: ItemDiff<T>[] = [];\n    itemsB.forEach((item, index) => {\n      if (!itemsAKeys.includes(item[this.trackBy])) {\n        diff.push({ value: item, index });\n      }\n    });\n    return diff;\n  }\n\n  private getItemDifferenceForEqualLength(itemsA: T[], itemsB: T[]): ItemDiff<T>[] {\n    const itemsAKeys = itemsA.map(item => item[this.trackBy]);\n    const diff: ItemDiff<T>[] = [];\n    itemsB.forEach((item, index) => {\n      if (!itemsAKeys.includes(item[this.trackBy])) {\n        diff.push({ value: item, index });\n      } else {\n        const previousObjectindex = itemsA.findIndex((prevItem) => {\n          return prevItem[this.trackBy] === item[this.trackBy];\n        });\n        if (previousObjectindex !== -1 && itemsA[previousObjectindex] !== item) {\n          diff.push({ value: item, index });\n        }\n      }\n    });\n    return diff;\n  }\n}\n","import {\n  Component, OnInit, Output, EventEmitter, Input,\n  ViewChild, ElementRef, SimpleChanges, OnChanges, ViewEncapsulation\n} from '@angular/core';\nimport { ItemMeta, ItemChange, ScrollToOptions } from './ngx-vscroll.interface';\nimport { ChangeOperation } from './ngx-vscroll.enum';\nimport { NgxVScrollService } from './ngx-vscroll.service';\n\n@Component({\n  selector: 'ngx-vscroll',\n  templateUrl: './ngx-vscroll.component.html',\n  styleUrls: ['./ngx-vscroll.component.scss'],\n  encapsulation: ViewEncapsulation.None\n})\nexport class NgxVScrollComponent<T> implements OnInit, OnChanges {\n\n  constructor(\n    private scrollerService: NgxVScrollService<T>\n  ) {\n    this.setDefaults();\n  }\n\n  @Output() viewportItems = new EventEmitter<T[]>();\n  @Output() scrollEnd = new EventEmitter<T[]>();\n\n  @Input() items: T[];\n  @Input() buffer: number;\n  @Input() trackBy: string;\n\n  private clonedViewportItems: T[];\n  private itemMeta: ItemMeta<T>[];\n  private maxYOffset: number;\n  private lastStartIndex: number;\n  private lastCount: number;\n  private mutationObservers: MutationObserver[];\n  scrollHeight: number;\n  private isScrolling;\n  private isScrollingEvent;\n\n  @ViewChild('scrollParent', { static: false }) scrollParentElementRef: ElementRef<HTMLDivElement>;\n  get scrollParentDiv(): HTMLDivElement {\n    return this.scrollParentElementRef && this.scrollParentElementRef.nativeElement;\n  }\n\n  @ViewChild('scrollItems', { static: false }) scrollItemsElementRef: ElementRef<HTMLDivElement>;\n  get scrollItemsDiv(): HTMLDivElement {\n    return this.scrollItemsElementRef && this.scrollItemsElementRef.nativeElement;\n  }\n\n  ngOnInit() {\n    if (!this.trackBy) {\n      throw new Error('ItemKey must be set to determine the changes and calculations of scroll offsets');\n    } else {\n      this.scrollerService.trackBy = this.trackBy;\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    const itemsChange = changes.items;\n    if (itemsChange) {\n      if (itemsChange.firstChange || (itemsChange.previousValue as []).length === 0) {\n        this.initialRender();\n      } else {\n        const changeData = this.scrollerService.onItemChange(\n          itemsChange.previousValue,\n          itemsChange.currentValue\n        );\n        this.handleItemChange(changeData);\n      }\n    }\n  }\n\n  scrollTo(options: ScrollToOptions) {\n    const top = options.offsetTop || this.itemMeta[options.index].offsetTop;\n    this.scrollParentDiv.scrollTo({ top });\n  }\n\n  getItemIndex(virtualIndex: number): number {\n    return this.lastStartIndex + virtualIndex;\n  }\n\n  private setDefaults() {\n    this.clonedViewportItems = [];\n    this.itemMeta = [];\n    this.maxYOffset = 0;\n    this.scrollHeight = 0;\n    this.buffer = 10;\n    this.lastStartIndex = 0;\n    this.lastCount = this.buffer;\n    this.mutationObservers = [];\n  }\n\n  private initialRender() {\n    // Render all items to process the meta\n    this.setViewportItems(this.items);\n\n    // Wait a tick for angular to render\n    // TODO: do it outside angular zone\n    setTimeout(() => {\n      this.processItemMeta();\n      this.setScrollHeight();\n      this.setViewportItems(this.items.slice(0, this.buffer));\n\n      // Wait a tick for angular to render\n      setTimeout(() => {\n        this.attachMutationObservers();\n      });\n    });\n  }\n\n  private setViewportItems(items: T[]) {\n    this.clonedViewportItems = Array.from(items);\n    this.viewportItems.emit(items);\n  }\n\n  private processItemMeta() {\n    const htmlElements = this.getHtmlElements();\n    htmlElements.forEach((element, index) => {\n      this.itemMeta.push({\n        offsetTop: element.offsetTop,\n        height: element.getBoundingClientRect().height,\n        value: this.items[index]\n      });\n    });\n  }\n\n  private getHtmlElements() {\n    const elementCollection = this.scrollItemsDiv.childNodes;\n    const elementArray = Array.from(elementCollection) as HTMLElement[];\n    return elementArray.filter(element => element.nodeType === 1);\n  }\n\n  private setScrollHeight() {\n    // Last item offsetTop is the max\n    const lastItem = this.itemMeta[this.itemMeta.length - 1];\n    this.maxYOffset = lastItem.offsetTop;\n\n    // The scroll's height with be the same as the last elements offsetTop plus it's height\n    this.scrollHeight = this.maxYOffset + lastItem.height;\n  }\n\n\n  onScroll() {\n    clearTimeout(this.isScrolling);\n    clearTimeout(this.isScrollingEvent);\n    this.isScrolling = setTimeout(() => {\n      this.handleScroll();\n    }, 15);\n    this.isScrollingEvent = setTimeout(() => {\n      this.scrollEnd.emit();\n    }, 200);\n  }\n\n  handleScroll() {\n    // Get the user's current scroll position\n    const scrollPosition = this.scrollParentDiv.scrollTop;\n\n    // If we are already at the bottom of the list then don't do anything else\n    // and nsure the offset does not exceed the scroll-size height\n    if (scrollPosition >= this.maxYOffset) {\n      this.updateOffsetYPosition(this.maxYOffset);\n      return;\n    }\n\n    // Find the closest row to our current scroll position\n    const closestRowIndex = this.scrollerService.getClosestItemIndex(scrollPosition, this.itemMeta);\n\n    // Find the rows that we need to render using the buffer\n    const viewportMeta = this.scrollerService.getViewportMeta(closestRowIndex, this.buffer, this.itemMeta);\n\n    if (viewportMeta.startIndex !== this.lastStartIndex || viewportMeta.count !== this.lastCount) {\n      this.lastStartIndex = viewportMeta.startIndex;\n      this.lastCount = viewportMeta.count;\n\n      this.deattachMutationObserver();\n\n      // // Get new viewport item acc to start and end indexes\n      const items = this.items.slice(viewportMeta.startIndex, viewportMeta.count);\n      this.setViewportItems(items);\n\n      // Being to update the offset's Y position once we have rendered at least 10 elements\n      const updatePosition = Math.max(0, closestRowIndex - this.buffer) === 0 ? 0 : this.itemMeta[viewportMeta.startIndex].offsetTop;\n\n      this.updateOffsetYPosition(updatePosition);\n\n      // Wait a tick for angular to render\n      setTimeout(() => {\n        this.attachMutationObservers();\n      });\n    }\n  }\n\n  private handleItemChange(change: ItemChange<T>) {\n    switch (change.operation) {\n      case ChangeOperation.ADD:\n        this.handleAddChange(change);\n        break;\n      case ChangeOperation.UPDATE:\n        this.handleUpdateChange(change);\n        break;\n      case ChangeOperation.REMOVE:\n        this.handleRemoveChange(change);\n        break;\n      default:\n        break;\n    }\n  }\n\n  private handleAddChange(change: ItemChange<T>) {\n    // Get the user's current scroll position\n    const scrollPosition = this.scrollParentDiv.scrollTop;\n\n    // Render the new added items to end on the viewport, this will\n    // perform optimization when re-rendering them to it's orginal position\n    const addedItems = change.diff.map(diff => diff.value);\n    this.clonedViewportItems.push(...addedItems);\n    this.setViewportItems(this.clonedViewportItems);\n\n    // Wait a tick for angular to render them\n    setTimeout(() => {\n      // Get rendered item and update item meta\n      const renderedElement = this.getHtmlElements();\n      this.scrollerService.processItemMetaForAdd(change.diff, renderedElement, this.itemMeta);\n\n      // Update viewport back to it's original items;\n      const items = this.items.slice(this.lastStartIndex, this.lastCount);\n      this.setViewportItems(items);\n      this.setScrollHeight();\n\n      // Wait a tick for angular to re-render the added items to it's\n      // original position and scroll back to user original scroll position\n      setTimeout(() => {\n        this.scrollParentDiv.scrollTo({ top: scrollPosition });\n      });\n    });\n  }\n\n  private handleUpdateChange(change: ItemChange<T>) {\n    // Get the user's current scroll position\n    const scrollPosition = this.scrollParentDiv.scrollTop;\n\n    // Find the change that are outside the viewport\n    const updatedItemsOutsideViewport = change.diff\n      .filter(diff => !(diff.index <= this.lastCount && diff.index >= this.lastStartIndex));\n\n    if (updatedItemsOutsideViewport.length) {\n      // Render the items that are outside viewport, this will\n      // perform optimization when re-rendering them to it's orginal position\n      this.clonedViewportItems.push(...updatedItemsOutsideViewport.map(diff => diff.value));\n      this.setViewportItems(this.clonedViewportItems);\n\n      // Wait a tick for angular to render them\n      setTimeout(() => {\n        // Get rendered element and adjust item meta accordingly\n        const renderedElements = this.getHtmlElements();\n        this.scrollerService.processItemMetaForUpdate(updatedItemsOutsideViewport, renderedElements, this.itemMeta);\n\n        // Rerender the original items\n        const items = this.items.slice(this.lastStartIndex, this.lastCount);\n        this.setViewportItems(items);\n        this.setScrollHeight();\n\n        // Wait a tick for angular to re-render the added items to it's\n        // original position and scroll back to user original scroll position\n        setTimeout(() => {\n          this.scrollParentDiv.scrollTo({ top: scrollPosition });\n        });\n      });\n    } else {\n      const updatedItemsOnViewport = change.diff\n        .filter(diff => diff.index <= this.lastCount && diff.index >= this.lastStartIndex);\n\n      // Rerender the original items\n      const items = this.items.slice(this.lastStartIndex, this.lastCount);\n      this.setViewportItems(items);\n\n      // Wait a tick for angular to render them\n      setTimeout(() => {\n        // Get rendered element and adjust item meta accordingly\n        const renderedElements = this.getHtmlElements();\n        this.scrollerService.processItemMetaForUpdate(updatedItemsOnViewport, renderedElements, this.itemMeta);\n\n        this.setScrollHeight();\n\n        // Wait a tick for angular to re-render the added items to it's\n        // original position and scroll back to user original scroll position\n        setTimeout(() => {\n          this.scrollParentDiv.scrollTo({ top: scrollPosition });\n        });\n      });\n    }\n  }\n\n  private handleRemoveChange(change: ItemChange<T>) {\n    // Get the user's current scroll position\n    const scrollPosition = this.scrollParentDiv.scrollTop;\n\n    // Update the item meta of the items that are removed\n    this.scrollerService.processItemMetaForRemove(change.diff, this.itemMeta);\n\n    // Update viewport\n    const items = this.items.slice(this.lastStartIndex, this.lastCount);\n    this.setViewportItems(items);\n    this.setScrollHeight();\n\n    // Wait a Tick for new Items to be rendered\n    setTimeout(() => {\n      // Now set the scroll to it's previous position before the change\n      this.scrollParentDiv.scrollTo({ top: scrollPosition });\n    });\n  }\n\n  private updateOffsetYPosition(position: number) {\n    this.scrollItemsDiv.style.transform = `translateY(${position}px)`;\n  }\n\n  private attachMutationObservers() {\n    const elements = this.getHtmlElements();\n    elements.forEach((element, index) => {\n      const itemIndex = this.getItemIndex(index);\n      const observer = new MutationObserver(() => this.onObserve(element, itemIndex));\n      observer.observe(element,\n        { subtree: true, childList: true });\n      this.mutationObservers.push(observer);\n    });\n  }\n\n  private onObserve(element: Element, itemIndex: number) {\n    const currentHeight = element.getBoundingClientRect().height;\n    if (currentHeight === this.itemMeta[itemIndex].height) {\n      return;\n    }\n\n    const adjustmentOffset = currentHeight - this.itemMeta[itemIndex].height;\n    this.itemMeta[itemIndex].height = currentHeight;\n    for (let index = itemIndex + 1; index < this.itemMeta.length; index++) {\n      const itemMeta = this.itemMeta[index];\n      itemMeta.offsetTop += adjustmentOffset;\n    }\n    this.setScrollHeight();\n  }\n\n  private deattachMutationObserver() {\n    this.mutationObservers.forEach(observer => {\n      observer.disconnect();\n    });\n    this.mutationObservers = [];\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { NgxVScrollComponent } from './ngx-vscroll.component';\n\n\n\n@NgModule({\n  declarations: [NgxVScrollComponent],\n  imports: [\n  ],\n  exports: [NgxVScrollComponent]\n})\nexport class NgxVScrollModule { }\n"]}